# 목차

> 요약 및 결론  
> 책 내용  

---

#### 요약 및 결론
- 
---

#### 책 내용
0. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
    - 소프트웨어 개발 방법을 획기적으로 뒤집는 두 가지 추세
        1. 하드웨어 관련
        2. 애플리케이션 구성 관련
            - MSA가 유행하면서 서비스가 작아진 대신 네트워크 통신 증가(매시업 애플리케이션)
            - 매시업 애플리케이션에서 하나의 서비스의 응답을 기다리는 동안 다른 서비스를 처리하지 않을 이유가 없다.
            - Java는이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공한다.
                1. Future 인터페이스
                2. 플로 API
1. 동시성을 구현하는 자바 지원의 진화
    - 최초 : Runnable과 Thread를 동기화된 클래스와 메서드를 이용해 잠금
    - Java 5 : 
        1. ExecuterService 인터페이스 : Executor인터페이스를 상속받으며 Callable을 실행하는 submit 메서드를 포함
        2. Runnable과 Thread의 변형을 반환하는 Callable<T>, Future<T>, 제네릭 지원
    - Java 7 : 분할정복 알고리즘의 포크/조인 구현을 지원하는 RecursiveTask 추가
    - Java 8 : 스트림과 새로 추가된 람다 지원에 기반한 병렬 프로세싱 추가
    - Java 9 : 분산 비동기 프로그래밍을 명시적으로 지원 
        - 리액티브 프로그래밍
        - 발행-구독 프로토콜로 이를 지원
    1. 스레드와 높은 수준의 추상화
        - 숫자 1,000,000개 배열을 처리하는 예제
        ```
        int[] stats = {1, 2, ... , 1_000_000};
        //네 개의 스레드를 만들어 계산
        long sum0 = 0;
        for(int i = 0 ; i < 250_000; i++) {
          sum0 += stats[i];
        }
        //내부반복을 통해 병렬성을 달성(스레드 사용 패턴 추상화)
        Arrays.stream(stats).parallel().sum();
        ```
    2. Executor와 스레드 풀
        - Java 5는 프레임워크와 스레드 풀을 통해 프로그래머가 태스크 제출과 실행을 분리할 수 있는 기능을 제공했다.
        - 스레드의 문제
            - 자바 스레드는 직접 운영체제 스레드에 접근한다.
            - 운영체제가 지원하는 스레드 수를 초과해 사용하면 예상치 못한 방식으로 크래시 될 수 있다.
        - 스레드 풀 그리고 스레드 풀이 더 좋은 이유
            - 자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다.
            - 프로그램은 newFixedThreadPool같은 팩토리 메서드 중 하나를 이용해 스레드 풀을 만들어 사용할 수 있다.
            ```
            @Test
            public void makeThreadPool() {
              // 워커 스레드라 불리는 nThreads를 포함하는 ExecutorService를 만들고 이들을 스레드 풀에 저장한다.
              // 스레드 풀에서 사용하지 않은 스레드를 가지고, 제출된 태스크를 먼저 온 순서대로 실행한다.
              // 이들 태스크 실행이 종료되면 사용했던 스레드를 스레드풀로 반환한다.
              // 장점 : 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 스레드 풀에 아무 오버헤드 없이 제출할 수 있다.
              // 큐의 크기 조정, 거부 정책, 태스크 종류에 따른 우선순위 등 다양한 설정을 할 수 있다.
              ExecutorService executorService = Executors.newFixedThreadPool(1);
              log.info("executorService : {}", executorService.toString());
              //executorService : java.util.concurrent.ThreadPoolExecutor@51dcb805[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0]
            }
            ```
        - 스레드 풀 그리고 스레드 풀이 나쁜 이유
            - 거의 모든 관점에서 스레드를 직접 사용하는 것보다 스레드 풀을 이용하는 것이 바람직하다.
            - 그러나 두 가지 사항을 주의해야 한다.
            1. 블록(자거나 이벤트를 기다리는)할 수 있는 태스크는 스레드풀에 제출하지 말아야 한다.
            2. 프로그램을 종료하기 전에 모든 스레드 풀을 종료하는 습관을 갖는 것이 중요하다.
            - 별로 안나빠 보이는뎅
    3. 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
        - 엄격한 포크/조인
            - 태스크나 스레드가 메서드 호출 안에서 시작되면 그 메서드 호출은 반환하지 않고 작업이 끝나기를 기다린다.
            - 스레드 생성과 join()이 한 쌍처럼 중첩된 메서드 호출 내에 추가되는 방식
            - 병렬 스트림과 포크/조인 프레임워크의 동시성
        - 여유로운 포크/조인(비동기 메서드)
            - 메서드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메서드
        - 그래서 뭐?
    4. 스레드에 무엇을 바라는가?
        - 일반적으로 프로그램을 작은 태스크 단위로 구조화하는 것이 목표이다.
        - 스레드를 조작하는 복잡한 코드를 구현하지 않고 메서드를 호출하는 방법을 살펴보자.
2. 동기 API와 비동기 API
    - Java 8 스트림을 이용해 명시적으로 병렬 하드웨어를 이용하는 방법을 이미 배웠다.
        - 외부 반복을 내부 반복으로 바꾸고, 스트림에 parallel()메서드를 이용한다.
            
            