# 목차

> 요약 및 결론  
> 책 내용  

---

## 요약 및 결론
- 자바8은 자바 역사상 가장 큰 변화가 일어난 버전이라고 한다.
- 잘 배웠다.

## 책 내용
### 1. 자바 8의 기능 리뷰
> 자바 8에 추가된 대부분의 새로운 기능은, 자바에서 함수형 프로그래밍을 쉽게 적용하도록 도와준다.
> 
> 변화의 목적 : 급격하게 좋아진 머신성능 최적 활용, 간결한 컬렉션 처리 
1. 동작 파라미터화
    - 람다와 메서드 참조
    - 메서드로 전달되는 값(파라미터로 넘기는 동작)은 Function, Predicate, BiFunction등의 형식을 갖는다.
    - 메서드를 수신한 코드에서는 apply, test 등의 메서드를 동해 전달받은 코드를 실행할 수 있다.
2. 스트림
    - 기존 컬렉션에 filter, map 등의 메서드를 추가하지 않고 스트림을 만든 이유?
        - 파이프라인으로 연결하기 불편함
        - 스트림은 스트림생성-중간연산-최종연산 연결하기 좋음
    - 쉬운 병렬처리(parallel(), 병렬스트림)
    - 함수형 개념의 핵심 : 외부 반복 대신 내부 반복 지원, 부작용 없는 연산(final 같은 변수만 사용), 메서드 파라미터화
3. CompletableFuture 클래스
    - 자바 5 부터 생긴 Future 인터페이스
        - 생성된 Future가 완료될 때 까지 기다릴 수 있다.
    - CompletableFuture와 Future의 관계는 스트림과 컬렉션의 관계와 같다.
        - thenCompose, thenCombine, allOf등을 제공한다.
        - 공통 디자인 패턴을 위 메서드들을 통해 함수형 프로그래밍으로 간결하게 표현할 수 있다.
    - 이와 같은 연산 형식은 Optional에도 적용된다.
4. Optional 클래스
    - 값이 없을 때 에러를 발생시킬 수 있는 null 대신 정해진 데이터 형식을 제공할 수 있다.
    - map, filter, ifPresent 등 상황에 맞게 빈 값을 처리하기 위한 메서드를 제공한다.
5. Flow API
    - 자바 9에서 리액티브 스트림, 리액티브 당김 기반 역압력 프로토콜을 표준화했다.
    - Publisher, Subscriber, Subscription, Processor를 포함한다.
6. 디폴트 메서드
    - 자바 8 이전에는 인터페이스에서 메서드 시그니처만 정의할 수 있었다.
    - 디폴트 메서드는 인터페이스에서 메서드의 기본 구현을 제공한다.
### 2. 자바 9 모듈 시스템
> 모듈 시스템의 장점
1. 안정적 설정 : 문제를 런타임이 아니라 빌드 과정에서 미리 확인할 수 있다.
2. 강한 캡슐화 : 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분과 내부 구현의 영역 접근을 분리할 수 있다.
3. 보안성 개선 : 모듈의 특정 부분을 사용할 수 없도록 제어 할 수 있다.
4. 성능 개선 : 클래스가 런타임이 로드된 다른 클래스를 참조하는 것 보다 적은 수의 컴포넌트를 참조할 때 최적화 기술이 더 효과를 발휘한다.
5. 확장성 : 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 애플리케이션에서 필요한 부분만 사용할 수 있다.

### 3. 자바 10 지역 변수형 추론
> 형식이 생략되면 컴파일러가 생략된 형식을 추론한다.
> 
> 초깃값이 없을 때는 var를 사용할 수 없다.
```
자바 10 이전 형식 추론
Map<String, Integer> map = new HashMap<String, Integer>();
Map<String, Integer> map = new HashMap();

Function<Integer, Boolean> p = (Integer x) -> booleanExpression;
Function<Integer, Boolean> p = x -> booleanExpression;
```
```
자바 10 형식 추론
Map<String, Integer> map = new HashMap<String, Integer>();
var map = new HashMap<String, Integer>();
```
### 4. 자바의 미래
> 앞으로 적용 될 것으로 보이는 내용들
1. 선언 사이트 변종
    - 자바는 제네릭의 서브형식을 와일드카드로 지정할 수 있는 유연성을 허용한다.
    ```java
    public class Ch21Conclusion {  
      @Test
      void generic() {
        List<? extends Number> numberList = new ArrayList<Integer>();
        // List<Number> numbers = new ArrayList<Integer>(); 얘는 에러
      }  
    }
    ```
    - 선언 사이트 변종이 적용되면 '? extends', '? super'를 사용할 필요가 없어진다.
2. 패턴 매칭
    - 패턴 매칭 : switch를 개선한 기능
    - 없어도 그만 있어도 그만일 것 같은데?
        - 함수형 프로그래밍 관점에서는 관련 코드가 여러 클래스 정의로 흩어지는 결과를 초래하기 때문에 있는게 낫다.
3. 풍부한 형식의 제네릭
    > 자바 제네릭의 두 가지 한계를 살펴보고 해결 방법을 설명
    - 구체화된 제네릭
        - ArrayList<Integer>나 ArrayList<String>이나 모두 런타임 표현이 같다
            - a.get(), a.remove() 이런거?
        - 제네릭 다형성의 삭제 모델이라고 한다.
        - GC는 런타임에 ArrayList의 콘텐츠 형식 정보를 확인할 수 없으므로 Integer인지 int인지 분간할 수 없다.
        - 구체화된 제네릭이란 형식정보를 런타임에 유지한 제네릭이라는 의미  
    - 제네릭이 함수 형식에 제공하는 문법적 유연성
        - 제네릭은 다양한 람다 형식과 메서드 참조를 표현하는 데 도움이 된다.
    - 기본형 특화와 제네릭
        - 자바의 모든 기본 자료형에는 대응하는 객체형이 존재한다.
        - 런타임 효율성은 조금 증가했지만 형식은 오히려 혼란스러워졌다.
        - 뭘 말하려는 건지;;
4. 더 근본적인 불변성 지원
    - 자바에서 함수형 프로그래밍을 구현하려면 '불변값'을 언어적으로 지원해야 한다.
5. 값 형식
    - 기본형과 객체형의 차이를 살펴보면서 값 형식이 필요한 이유 설명
    - 컴파일러가 Integer와 int를 같은 값으로 취급할 수는 없나?
        - 없다고 한다.
    - 변수형 : 모든 것을 기본형이나 객체형으로 양분하지 않는다.
        - var처럼 쓰자는 이야기
    - 박싱, 제네릭, 값 형식 : 상호 의존 문제
        - 함수형 프로그래밍에서는 식별자가 없는 불변값을 이용하므로 자바에서 값 형식을 지원한다면 좋을 것이다.
        - 난 지금 좋은데
### 5. 더 빠르게 발전하는 자바
1. 자바 버전
    - 자바 14 : 2020-03-18
    - 자바 15 : 2020-09-15
    - 자바 16 : 2021 예정
    - 자바 17 : 2021 예정
2. 그 다음은 모름
### 6. 결론
- 자바 8은 자바 역사를 통틀어 가장 큰 변화가 일어난 버전이다.
- 그 다음으로 큰 변화는 자바 5 제네릭